#' Build Minimal Spanning Tree
#' 
#' Add minimal spanning tree description to the FlowSOM object
#' 
#' @param fsom   FlowSOM object, as generated by \code{\link{BuildSOM}}
#' @param silent If \code{TRUE}, no progress updates will be printed
#' @param tSNE   If \code{TRUE}, an alternative tSNE layout is computed as well
#' 
#' @return FlowSOM object containing MST description
#' 
#' @seealso \code{\link{BuildSOM}}, \code{\link{PlotStars}}
#' 
#' @examples 
#' # Read from file, build self-organizing map
#' fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#' flowSOM.res <- ReadInput(fileName, compensate=TRUE,transform=TRUE,
#'                          scale=TRUE)
#' flowSOM.res <- BuildSOM(flowSOM.res,colsToUse=c(9,12,14:18))
#' 
#' # Build the Minimal Spanning Tree
#' flowSOM.res <- BuildMST(flowSOM.res)
#' 
#' @export
BuildMST <- function(fsom, silent=FALSE, tSNE=FALSE){

    fsom$MST <- list()
    if(!silent) message("Building MST\n")
    
    adjacency <- dist(fsom$map$codes, method = "euclidean")
    fullGraph <- graph.adjacency(as.matrix(adjacency), mode = "undirected", 
                                weighted = TRUE)
    fsom$MST$graph <- minimum.spanning.tree(fullGraph)
    fsom$MST$l <- layout.kamada.kawai(fsom$MST$graph)    
    
    if(tSNE){
        fsom$MST$l2 <- tsne(fsom$map$codes)   
        #library(RDRToolbox)
        #fsom$MST$l2 <- Isomap(fsom$map$codes,dims=2,k=3)[[1]]
    }
    
    UpdateNodeSize(fsom)
}

#' Update nodesize of FlowSOM object
#' 
#' Add size property to the graph based on cellcount for each node
#' 
#' @param fsom     FlowSOM object, as generated by \code{\link{BuildMST}}
#' @param reset    Logical. If \code{TRUE}, all nodes get the same size
#' @param transform Transformation function. Use e.g. square root to let counts
#'                 correspond with area of node instead of radius
#' 
#' @return Updated FlowSOM object
#' @seealso \code{\link{BuildMST}}
#' 
#' @examples 
#' # Read from file, build self-organizing map and minimal spanning tree
#' fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#' flowSOM.res <- ReadInput(fileName, compensate=TRUE,transform=TRUE,
#'                         scale=TRUE)
#' flowSOM.res <- BuildSOM(flowSOM.res,colsToUse=c(9,12,14:18))
#' flowSOM.res <- BuildMST(flowSOM.res)
#'
#' # Give all nodes same size
#' flowSOM.res <- UpdateNodeSize(flowSOM.res,reset=TRUE)
#' PlotStars(flowSOM.res)
#'
#' # Node sizes relative to amount of cells assigned to the node
#' flowSOM.res <- UpdateNodeSize(flowSOM.res)
#' PlotStars(flowSOM.res)
#' 
#' @export
UpdateNodeSize <- function(fsom, reset=FALSE, transform=NULL){
    if(reset){
        fsom$MST$size <- rep(15, nrow(fsom$map$grid))
    } else {
        t <- table(fsom$map$mapping[, 1])
        if(!is.null(transform)){
            t <- transform(t)
        }
        rescaled <- 14* (t - min(t))/max((t - min(t)))
        fsom$MST$size <- numeric(nrow(fsom$map$grid))
        fsom$MST$size[as.numeric(names(t))] <- rescaled    
    }
    fsom
}

#' Plot marker values
#' 
#' Plot FlowSOM grid or tree, coloured by node values for a specific marker
#' 
#' @param fsom         FlowSOM object, as generated by \code{\link{BuildMST}}
#' @param marker       Name or index of marker to plot
#' @param view     Preferred view, options: "MST", "grid" or "tSNE" (if this
#'                 option was selected while building the MST)
#' @param main         Title of the plot
#' @param colorPalette Color palette to use
#' 
#' @return Nothing is returned. A plot is drawn in which each node 
#'         is coloured depending on its median value for the given marker
#' @references This visualization technique resembles SPADE results. 
#' M. Linderman, P. Qiu, E. Simonds and Z. Bjornson (). spade: SPADE -- An 
#' analysis and visualization tool for Flow Cytometry. R package version 1.12.2.
#' http://cytospade.org
#' @seealso \code{\link{PlotStars}},\code{\link{PlotPies}},
#'          \code{\link{PlotCenters}},\code{\link{BuildMST}}
#' 
#' @examples 
#' # Read from file, build self-organizing map and minimal spanning tree
#' fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#' flowSOM.res <- ReadInput(fileName, compensate=TRUE,transform=TRUE,
#'                          scale=TRUE)
#' flowSOM.res <- BuildSOM(flowSOM.res,colsToUse=c(9,12,14:18))
#' flowSOM.res <- BuildMST(flowSOM.res)
#' 
#' # Plot one marker
#' PlotMarker(flowSOM.res,"FSC-A")
#' 
#' @export
PlotMarker <- function(fsom, marker=NULL, view=TRUE,main=NULL, 
                        colorPalette=colorRampPalette(c("#00007F", "blue", 
                        "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00",
                        "red", "#7F0000"))){
    switch(view,
            MST  = { layout <- fsom$MST$l 
            lty <- 1},
            grid = { layout <- as.matrix(fsom$map$grid)
            lty <- 0},
            tSNE = { layout <- fsom$MST$l2
            lty <- 0}
    )
    
    if(is.null(main)) main <- marker
    
    if(is.null(marker)){
        plot(fsom$MST$graph, layout=layout, vertex.size=fsom$MST$size, 
            vertex.label=NA,edge.lty=lty)
    }else{
        f <- fsom
        V(f$MST$graph)$color <- colorPalette(100)[as.numeric(cut(
            fsom$map$medianValues[, marker], breaks = 100))] 
        plot(f$MST$graph, layout=layout, vertex.size=fsom$MST$size, 
            vertex.label=NA, main=main,edge.lty=lty)
    }
}

#' Plot a variable for all nodes
#' 
#' Plot FlowSOM grid or tree, coloured by node values given in variable
#' 
#' @param fsom         FlowSOM object, as generated by \code{\link{BuildMST}}
#' @param variable     Vector containing a value for each node
#' @param view         Preferred view, options: "MST", "grid" or "tSNE" (if this
#'                     option was selected while building the MST)
#' @param main         Title of the plot
#' @param colorPalette Color palette to use
#' 
#' @return Nothing is returned. A plot is drawn in which each node 
#'         is coloured depending on its value for the given variable
#' @seealso \code{\link{PlotMarker}},\code{\link{PlotStars}},
#'          \code{\link{PlotPies}},\code{\link{PlotCenters}},
#'          \code{\link{BuildMST}}
#' 
#' @examples 
#' # Read from file, build self-organizing map and minimal spanning tree
#' fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#' flowSOM.res <- ReadInput(fileName, compensate=TRUE,transform=TRUE,
#'                          scale=TRUE)
#' flowSOM.res <- BuildSOM(flowSOM.res,colsToUse=c(9,12,14:18))
#' flowSOM.res <- BuildMST(flowSOM.res)
#' 
#' # Plot some random values
#' rand <- runif(flowSOM.res$map$nNodes)
#' PlotVariable(flowSOM.res,rand)
#' 
#' @export
PlotVariable <- function(fsom, variable, view="MST",main=NULL, 
                        colorPalette=colorRampPalette(c("#00007F", "blue", 
                        "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00",
                        "red", "#7F0000"))){
    switch(view,
            MST  = { layout <- fsom$MST$l 
            lty <- 1},
            grid = { layout <- as.matrix(fsom$map$grid)
            lty <- 0},
            tSNE = { layout <- fsom$MST$l2
            lty <- 0}
    )
    
    oldpar <- par(no.readonly = TRUE)
    par(mar=c(1,1,1,1))
    layout(matrix(c(1,2), 1, 2, byrow = TRUE), 
            widths=c(1,2), heights=c(1))
    plot.new()
    legend.col(colorPalette(100),variable)

    f <- fsom
    V(f$MST$graph)$color <- colorPalette(100)[as.numeric(cut(
        variable, breaks = 100))] 
    plot(f$MST$graph, layout=layout, vertex.size=fsom$MST$size, 
        vertex.label=NA, main=main,edge.lty=lty)
    
    par <- oldpar
}

#' Plot the index of each node
#' 
#' Plot FlowSOM grid or tree, with in each node a number indicating it's index
#' 
#' @param fsom         FlowSOM object, as generated by \code{\link{BuildMST}}
#' @param view     Preferred view, options: "MST", "grid" or "tSNE" (if this
#'                 option was selected while building the MST)
#' @param main         Title of the plot
#' 
#' @return Nothing is returned. A plot is drawn in which each node 
#'         is assigned a number
#' @seealso \code{\link{PlotMarker}},\code{\link{PlotStars}},
#'          \code{\link{PlotPies}},\code{\link{PlotCenters}},
#'          \code{\link{BuildMST}}
#' 
#' @examples 
#' # Read from file, build self-organizing map and minimal spanning tree
#' fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#' flowSOM.res <- ReadInput(fileName, compensate=TRUE,transform=TRUE,
#'                          scale=TRUE)
#' flowSOM.res <- BuildSOM(flowSOM.res,colsToUse=c(9,12,14:18))
#' flowSOM.res <- BuildMST(flowSOM.res)
#' 
#' # Plot some random values
#' PlotNumbers(flowSOM.res)
#' 
#' @export
PlotNumbers <- function(fsom, view="MST",main=NULL){
    switch(view,
            MST  = { layout <- fsom$MST$l 
            lty <- 1},
            grid = { layout <- as.matrix(fsom$map$grid)
            lty <- 0},
            tSNE = { layout <- fsom$MST$l2
            lty <- 0}
    )
    
    plot(fsom$MST$graph, layout=layout, vertex.size=fsom$MST$size, 
        vertex.label=seq_len(nrow(fsom$map$codes)),edge.lty=lty)
    
}

#' Plot comparison with other clustering
#' 
#' Plot FlowSOM grid or tree, with pies indicating another clustering
#'    or manual gating result
#'
#' @param fsom      FlowSOM object, as generated by \code{\link{BuildMST}}
#' @param cellTypes Array of factors indicating the celltypes
#' @param view     Preferred view, options: "MST", "grid" or "tSNE" (if this
#'                 option was selected while building the MST)
#' @param colorPalette      Colorpalette to be used for the markers
#' @param backgroundValues  Values to be used for background coloring, either
#'                          numerical values or something that can be made into
#'                          a factor (e.g. a clustering)
#' @param backgroundColor   Colorpalette to be used for the background coloring
#'                          . Can be either a function or an array specifying
#'                          colors
#' @param backgroundBreaks  Breaks to pass on to \code{\link{cut}}, to split
#'                          numerical background values. If NULL, the length of
#'                          backgroundColor will be used (default 100).
#' @param legend   Logicle, if T add a legend
#' @param main     Title of the plot
#' 
#' @return Nothing is returned. A plot is drawn in which each node is 
#' represented by a pie chart indicating the percentage of cells present 
#' of each cell type. At the end, the layout is set to 1 figure again.
#' 
#' @seealso \code{\link{PlotStars}},\code{\link{PlotMarker}},
#' \code{\link{PlotCenters}},\code{\link{BuildMST}}
#'
#'  @examples 
#'    # Read from file, build self-organizing map and minimal spanning tree
#'    fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#'    flowSOM.res <- ReadInput(fileName, compensate=TRUE,transform=TRUE,
#'                             scale=TRUE)
#'    flowSOM.res <- BuildSOM(flowSOM.res,colsToUse=c(9,12,14:18))
#'    flowSOM.res <- BuildMST(flowSOM.res)
#'    
#'    # Get the manually gated labels using a gatingML file 
#'    # and the flowUtils library
#'     ff <- read.FCS(fileName)
#'    ff_c <- compensate(ff,ff@@description$SPILL)
#'    colnames(ff_c)[8:18] <- paste("Comp-",colnames(ff_c)[8:18],sep="")
#'    library(flowUtils)
#'    flowEnv <- new.env()
#'    gatingFile <- system.file("extdata","manualGating.xml", 
#'                              package="FlowSOM")
#'    read.gatingML(gatingFile, flowEnv) 
#'    filterList <- list( "B cells" = flowEnv$ID52300206,
#'                        "ab T cells" = flowEnv$ID785879196,
#'                        "yd T cells" = flowEnv$ID188379411,
#'                        "NK cells" = flowEnv$ID1229333490,
#'                        "NKT cells" = flowEnv$ID275096433
#'    )
#'    results <- list()
#'    for(cellType in names(filterList)){
#'        results[[cellType]] <- filter(ff_c,filterList[[cellType]])@@subSet
#'    }
#'    manual <- rep("Unknown",nrow(ff))
#'    for(celltype in names(results)){
#'        manual[results[[celltype]]] <- celltype
#'    }
#'    
#'    # Plot pies indicating the percentage of cell types present in the nodes
#'    PlotPies(flowSOM.res,manual)
#'
#' @export
PlotPies <- function(fsom, 
                    cellTypes, 
                    view="MST", #"grid","tSNE"
                    colorPalette=colorRampPalette(c("white","#00007F",
                        "blue", "#007FFF", "cyan", "#7FFF7F", "yellow",
                        "#FF7F00", "red")),
                    backgroundValues = NULL,
                    backgroundColor = function(n){rainbow(n,alpha=0.3)},
                    backgroundBreaks = NULL,
                    # colorRampPalette(c("#FFFFFF","#FF000077"),alpha=TRUE)
                    legend=TRUE,
                    main=""){

    # Choose pie values
    if(!is.factor(cellTypes)){
        cellTypes <- as.factor(cellTypes)
    }
    t <- table(factor(fsom$map$mapping[,1], 
                        levels=seq_along(fsom$MST$size)),
                factor(cellTypes,levels=c(levels(cellTypes),"empty")))
    t[rowSums(t)==0, "empty"] <- 1
    data <- unlist(apply(t, 1, list), recursive = FALSE)
    colors <- list(c(colorPalette(length(levels(cellTypes))),"#000000"))
    colors <- rep(colors,length(fsom$MST$size))
    
    # Choose layout type
    switch(view,
            MST  = { layout <- fsom$MST$l 
            lty <- 1},
            grid = { layout <- as.matrix(fsom$map$grid)
            lty <- 0},
            tSNE = { layout <- fsom$MST$l2
            lty <- 0}
    )
    
    # Choose background colour
    backgroundList <- list()
    backgroundColors <- NULL
    if(!is.null(backgroundValues)){
        if(is.numeric(backgroundValues)){
            backgroundList <- as.list(seq_along(backgroundValues))
            
            if(class(backgroundColor)=="function" & 
                !is.null(backgroundBreaks) & 
                length(backgroundBreaks)>1)
            {
                backgroundColor <- backgroundColor(length(backgroundBreaks))
            } else if (class(backgroundColor)=="function"){
                backgroundColor <- backgroundColor(100)
                backgroundBreaks <- length(backgroundColor)
            } else if (is.null(backgroundBreaks)){
                backgroundBreaks <- length(backgroundColor)
            }
            
            ids <- cut(backgroundValues,backgroundBreaks)
            backgroundColors <- backgroundColor[ids]    
        } else {
            if(! is.factor(backgroundValues)){
                backgroundValues <- as.factor(backgroundValues)
            }
            
            backgroundList <- as.list(seq_along(backgroundValues))
            
            if(class(backgroundColor)=="function"){
                backgroundColor <- backgroundColor(
                    length(levels(backgroundValues)))
            }
            
            if(length(backgroundColor) < length(levels(backgroundValues))){
                stop("You specified less backgroundcolours than groups.")
            }
            backgroundColors <- backgroundColor[backgroundValues]    
            
        }    
    }
    
    # Save plot window settings and minimize margin
    oldpar <- par(no.readonly = TRUE)
    par(mar=c(1,1,1,1))
    
    # Add legend
    if(legend){
        if(!is.null(backgroundValues)){
            # Make plot with folowing layout
            # 1 3
            # 2 3
            layout(matrix(c(1,3,2,3), 2, 2, byrow = TRUE), 
                    widths=c(1,2), heights=c(1))
            plot.new()
            legend("center",legend=levels(cellTypes), 
                    fill=colors[[1]], 
                    cex=0.7, ncol=1, bty="n")
            plot.new()
            if(is.factor(backgroundValues)){
                legend("center", legend=levels(backgroundValues),
                        fill=backgroundColor, 
                        cex=0.7, ncol=1, bty="n",title="Background")       
            } else {
                legend.col(backgroundColor,
                    as.numeric(gsub(".*,","",gsub("].*","",levels(ids)))))
            }
        } else {
            layout(matrix(c(1,2), 1, 2, byrow = TRUE), 
                    widths=c(1,2), heights=c(1))
            #layout(matrix(c(1,2), 2, 1, byrow = TRUE), 
            #       widths=c(1), heights=c(1,2))
            plot.new()
            legend("center",legend=levels(cellTypes), 
                    fill=colors[[1]], 
                    cex=0.7, ncol=1, bty="n")
        }
    }
    
    # Plot the actual graph
    plot(fsom$MST$g, 
        vertex.shape="pie", 
        vertex.label=NA, 
        vertex.size=fsom$MST$size, 
        vertex.pie=data,
        vertex.pie.color=colors,
        layout=layout, 
        edge.lty=lty, 
        mark.groups=backgroundList, 
        mark.col=backgroundColors, 
        mark.border=backgroundColors,
        main=main
    )
    
    # Reset plot window
    par <- oldpar
    layout(1)
}

# Internal use only:
# Add a new vertex shape to iGraph to make star charts
mystar <- function(coords, v=NULL, params) {
    vertex.color <- params("vertex", "color")
    if (length(vertex.color) != 1 && !is.null(v)) {
        vertex.color <- vertex.color[v]
    }
    vertex.size    <- 1/200 * params("vertex", "size")
    if (length(vertex.size) != 1 && !is.null(v)) {
        vertex.size <- vertex.size[v]
    }
    data <- params("vertex", "data")
    cP <- params("vertex","cP")
    stars(data, locations = coords, labels = NULL,#scale=FALSE, 
            len = vertex.size, col.segments = cP, 
            draw.segments = TRUE, mar = c(0, 0, 0, 0), add=TRUE, 
            inches=FALSE)
    symbols(coords[, 1], coords[, 2], circles = vertex.size, 
            inches = FALSE, bg = "transparent", bty='n', add=TRUE) 
    
}

# Internal use only, color gradient legend
legend.col <- function(col, lev){
    
    opar <- par
    n <- length(col)
    bx <- par("usr")
    
    box.cx <- c((bx[2]+bx[1])/2 - (bx[2] - bx[1]) / 50,
                (bx[2]+bx[1])/2 + (bx[2] - bx[1]) / 50)
    box.cy <- c(bx[3], bx[3])
    box.sy <- (bx[4] - bx[3]) / n
    
    xx <- rep(box.cx, each = 2)
    
    par(xpd = TRUE)
    yval <- seq(min(lev), max(lev),by=(max(lev)-min(lev))/n)

    for(i in 1:n){
        
        yy <- c(box.cy[1] + (box.sy * (i - 1)),
                box.cy[1] + (box.sy * (i)),
                box.cy[1] + (box.sy * (i)),
                box.cy[1] + (box.sy * (i - 1)))
        polygon(xx, yy, col = col[i], border = col[i])
        if((i==1) | (i%%ceiling(n/5)) == 0){
            text(x = box.cx[2]+ (bx[2] - bx[1]) / 50,
                y = box.cy[1]+(box.sy * (i - 0.5)),
                labels = format(yval[i], digits=3,nsmall=3),
                adj = c(0,0.5))
        }
    }
    par <- opar
}


shift <- function(x,n){
    c(x[(n+1):length(x)],x[1:n])
}

#' Plot legend for star plot
#' 
#' Plot a single star chart, annotated with labels
#'  
#' @param labels Names to show in the legend
#' @param colors Corresponding colors
#' @param main   Title of the legend
#'
#' @return Nothing is returned. A plot is drawn with 1 star chart, which is 
#' filled completely and annotated with the given labels.
#' @seealso \code{\link{PlotStars}}
plotStarLegend <- function(labels, colors=rainbow(length(labels)),main=""){
    plot(1, type="n", xlab="", ylab="", xlim=c(-10, 10), ylim=c(-3, 3),asp=1,
        bty="n",xaxt="n",yaxt="n",main=main)
    
    stars(matrix(c(1:(2*length(labels))),nrow=2),col.segments=colors,
        locations=c(0,0),draw.segments = TRUE,add=TRUE,
        inches=FALSE)
    n <- length(labels)
    angle <- 2*pi / n
    angles <- seq(angle/2,2*pi,by=angle)
    
    left <- (angles > (pi/2) & angles < (3*pi/2))
    x <- c(2,-2)[left+1]
    y_tmp <- c(seq(-2,2,by= 4/(sum(!left)+1))[-c(1,sum(!left)+2)],
                seq(2,-2,by=-4/(sum(left)+1))[-c(1,sum(left)+2)])
    y <- shift(y_tmp,max((cummax(y_tmp)<0)*seq_along(y_tmp)))
    
    for(i in seq_along(labels)){
        text(x= x[i], 
            y= y[i],
            labels=labels[i],
            adj = c(as.numeric(left)[i],0.5),
            cex = 0.5)
        
        lines(x=c(x[i]+c(-0.2,0.2)[left[i]+1],
                c(1.5,-1.5)[left[i]+1],
                cos(angles[i])),
            y=c(y[i],
                y[i],
                sin(angles[i])),
            col=colors[i],
            lwd=2)    
    }
}

plotStarQuery <- function(labels,values, 
                            colors=rainbow(length(labels)),main=""){
    #browser()
    plot(1, type="n", xlab="", ylab="", xlim=c(-10, 10), ylim=c(-3, 3),asp=1,
        bty="n",xaxt="n",yaxt="n",main=main)
    #stars(matrix(c(1:(2*length(labels))),nrow=2),col.segments=colors,
    #      locations=c(0,0),draw.segments = TRUE,add=TRUE,
    #      inches=FALSE)
    
    stars(matrix(c(rep(0,length(labels)),values),nrow=2,byrow=TRUE),
            col.segments=colors,
            locations=c(0,0),draw.segments = TRUE,add=TRUE,
            inches=FALSE)
    n <- length(labels)
    angle <- 2*pi / n
    angles <- seq(angle/2,2*pi,by=angle)
    
    left <- (angles > (pi/2) & angles < (3*pi/2))
    x <- c(2,-2)[left+1]
    y_tmp <- c(seq(-2,2,by= 4/(sum(!left)+1))[-c(1,sum(!left)+2)],
                seq(2,-2,by=-4/(sum(left)+1))[-c(1,sum(left)+2)])
    y <- shift(y_tmp,max((cummax(y_tmp)<0)*seq_along(y_tmp)))
    
    for(i in seq_along(labels)){
        text(x= x[i], 
            y= y[i],
            labels=labels[i],
            adj = c(as.numeric(left)[i],0.5),
            cex = 0.5)
        
        lines(x=c(x[i]+c(-0.2,0.2)[left[i]+1],
                c(1.5,-1.5)[left[i]+1],
                cos(angles[i])),
            y=c(y[i],
                y[i],
                sin(angles[i])),
            col=colors[i],
            lwd=2)    
    }
}

#' Plot star charts
#' 
#' Plot FlowSOM grid or tree, where each node is represented by 
#' a star chart indicating mean marker values
#' 
#' @param fsom     FlowSOM object, as generated by \code{\link{BuildMST}}
#' @param markers  Array of markers to use. Default: the markers used to build 
#'                 the tree
#' @param view     Preferred view, options: "MST", "grid" or "tSNE" (if this
#'                 option was selected while building the MST)
#' @param colorPalette      Colorpalette to be used for the markers
#' @param backgroundValues  Values to be used for background coloring, either
#'                          numerical values or something that can be made into
#'                          a factor (e.g. a clustering)
#' @param backgroundColor   Colorpalette to be used for the background coloring
#'                          . Can be either a function or an array specifying
#'                          colors
#' @param legend   Logical, if TRUE add a legend
#' @param query    Show a low/high profile for certain markers in the legend.
#'                 See also \code{\link{QueryStarPlot}}
#' @param main     Title of the plot
#' 
#' @return Nothing is returned. A plot is drawn in which each node is 
#' represented by a star chart indicating the median fluorescence intensities.
#' Resets the layout back to 1 plot at the end.
#' 
#' @seealso \code{\link{PlotPies}},\code{\link{PlotMarker}},
#' \code{\link{PlotCenters}}, \code{\link{BuildMST}}
#' 
#' @examples
#'    # Read from file, build self-organizing map and minimal spanning tree
#'    fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#'    flowSOM.res <- ReadInput(fileName, compensate=TRUE,transform=TRUE,
#'                             scale=TRUE)
#'    flowSOM.res <- BuildSOM(flowSOM.res,colsToUse=c(9,12,14:18))
#'    flowSOM.res <- BuildMST(flowSOM.res)
#'    
#'    # Plot stars indicating the MFI of the cells present in the nodes
#'    PlotStars(flowSOM.res)
#'
#' @export
PlotStars <- function(fsom, 
                        markers=fsom$map$colsUsed, 
                        view="MST", #"grid","tSNE"
                        colorPalette=colorRampPalette(
                            c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", 
                                "yellow", "#FF7F00", "red", "#7F0000")),
                        backgroundValues = NULL,
                        backgroundColor = function(n){rainbow(n,alpha=0.3)},
                        # colorRampPalette(c("#FFFFFF","#FF000077"),alpha=TRUE)
                        legend=TRUE,
                        query=NULL,
                        main=""){
    # Add star chart option to iGraph
    add.vertex.shape("star", clip=igraph.shape.noclip, plot=mystar, 
                    parameters=list(vertex.data=NULL,vertex.cP = colorPalette))
    
    # Choose star values
    data <- fsom$map$medianValues[, markers,drop=FALSE]
    
    # Choose layout type
    switch(view,
        MST  = { layout <- fsom$MST$l 
                    lty <- 1},
        grid = { layout <- as.matrix(fsom$map$grid)
                    lty <- 0},
        tSNE = { layout <- fsom$MST$l2
                    lty <- 0}
    )
    
    # Choose background colour
    backgroundList <- list()
    backgroundColors <- NULL
    if(!is.null(backgroundValues)){
        if(is.numeric(backgroundValues)){
            backgroundList <- as.list(seq_along(backgroundValues))
            
            if(class(backgroundColor)=="function"){
                backgroundColor <- backgroundColor(100)
            }
            
            ids <- cut(backgroundValues,length(backgroundColor))
            backgroundColors <- backgroundColor[ids]    
        } else {
            if(! is.factor(backgroundValues)){
                backgroundValues <- as.factor(backgroundValues)
            }
            
            backgroundList <- as.list(seq_along(backgroundValues))
            
            if(class(backgroundColor)=="function"){
                backgroundColor <- backgroundColor(
                                        length(levels(backgroundValues)))
            }
    
            if(length(backgroundColor) < length(levels(backgroundValues))){
                stop("You specified less backgroundcolours than groups.")
            }
            
            backgroundColors <- backgroundColor[backgroundValues]    
            
        }    
    }
    
    # Save plot window settings and minimize margin
    oldpar <- par(no.readonly = TRUE)
    par(mar=c(1,1,1,1))
    
    # Add legend
    if(legend){
        if(!is.null(backgroundValues)){
            # Make plot with folowing layout
            # 1 3
            # 2 3
            layout(matrix(c(1,3,2,3), 2, 2, byrow = TRUE), 
                    widths=c(1,2), heights=c(1))
            if(is.null(query)){
                plotStarLegend(fsom$prettyColnames[markers], 
                                colorPalette(ncol(data)))
            } else {
                plotStarQuery(fsom$prettyColnames[markers],
                                values=query == "high",
                                colorPalette(ncol(data)))
            }
            plot.new()
            if(is.factor(backgroundValues)){
                legend("center", legend=levels(backgroundValues),
                            fill=backgroundColor, 
                            cex=0.7, ncol=1, bty="n",title="Background")       
            } else {
                       legend.col(backgroundColor,backgroundValues)
            }
        } else {
            layout(matrix(c(1,2), 1, 2, byrow = TRUE), 
                    widths=c(1,2), heights=c(1))
            #layout(matrix(c(1,2), 2, 1, byrow = TRUE), 
            #       widths=c(1), heights=c(1,2))
            plotStarLegend(fsom$prettyColnames[markers], 
                            colorPalette(ncol(data)))
        }
    }
    
    # Plot the actual graph
    plot(fsom$MST$g, 
        vertex.shape="star", 
        vertex.label=NA, 
        vertex.size=fsom$MST$size, 
        vertex.data=data,
        vertex.cP=colorPalette(ncol(data)),
        layout=layout, 
        edge.lty=lty, 
        mark.groups=backgroundList, 
        mark.col=backgroundColors, 
        mark.border=backgroundColors,
        main=main
    )
    
    # Reset plot window
    par <- oldpar
    layout(1)
}


#' Plot nodes on scatter plot
#' 
#' Plot a 2D scatter plot. All cells of fsom$data are plotted in
#' black, and those of the selected nodes are plotted in red.
#' The nodes in the grid are indexed starting from the left bottom,
#' first going right, then up. E.g. In a 10x10 grid, the node at
#' top left will have index 91.
#'  
#' @param fsom    FlowSOM object, as generated by \code{\link{BuildMST}}
#' @param marker1 Marker to plot on the x-axis
#' @param marker2 Marker to plot on the y-axis
#' @param nodes   Nodes of which the cells should be plotted in red
#' @param main    Title of the plot
#' @param col     Colors for all the cells in the selected nodes (ordered array)
#' @param maxBgPoints Maximum number of background points to plot
#' @param ...     Other parameters to pass on to plot
#'
#' @return Nothing is returned. A plot is drawn in which all cells are plotted
#'         in black and the cells of the selected nodes in red.
#' @seealso \code{\link{PlotNumbers}},\code{\link{PlotCenters}},
#'          \code{\link{BuildMST}}
#' 
#' @examples
#'    # Read from file, build self-organizing map and minimal spanning tree
#'    fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#'    flowSOM.res <- ReadInput(fileName, compensate=TRUE,transform=TRUE,
#'                             scale=TRUE)
#'    flowSOM.res <- BuildSOM(flowSOM.res,colsToUse=c(9,12,14:18))
#'   flowSOM.res <- BuildMST(flowSOM.res)
#'    
#'    # Plot cells
#'    PlotClusters2D(flowSOM.res,1,2,91)
#'
#' @export

PlotClusters2D <- function(fsom, marker1, marker2, nodes, main="",
                            col = "#FF0000",maxBgPoints=NULL,...){
    if(!is.null(maxBgPoints)){
        background <- sample(seq_len(nrow(fsom$data)),
                            min(maxBgPoints,nrow(fsom$data)))
    } else{
        background <- seq_len(nrow(fsom$data))
    }
    plot(fsom$data[background, c(marker1, marker2)], 
        pch=".", col="#000000AA",main=main,
        xlab=fsom$prettyColnames[marker1],
        ylab=fsom$prettyColnames[marker2],
        ...)
    points(fsom$data[fsom$map$mapping[,1] %in% nodes, c(marker1, marker2)], 
            #pch=".", 
            col=col)
    points(fsom$map$meanValues[nodes,marker1],
            fsom$map$meanValues[nodes,marker2],
            pch="x",col="blue")
    #cat(nodes,": \n",table(m[fsom$map$mapping[,1] %in% nodes]),"\n")
}

#' Plot cluster centers on a 2D plot
#' 
#' Plot FlowSOM nodes on a 2D scatter plot of the data
#' 
#' @param fsom    FlowSOM object, as generated by \code{\link{BuildMST}}
#' @param marker1 Marker to show on the x-axis
#' @param marker2 Marker to show on the y-axis
#' @param MST     Type of visualization, if 1 plot tree, else plot grid
#' @return Nothing is returned. A 2D scatter plot is drawn on which the nodes 
#'         of the grid are indicated
#'         
#' @seealso \code{\link{PlotStars}},\code{\link{PlotPies}},
#'          \code{\link{PlotMarker}},\code{\link{BuildMST}}
#'          
#' @examples
#'    # Read from file, build self-organizing map and minimal spanning tree
#'    fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#'    flowSOM.res <- ReadInput(fileName, compensate=TRUE,transform=TRUE,
#'                             scale=TRUE)
#'    flowSOM.res <- BuildSOM(flowSOM.res,colsToUse=c(9,12,14:18))
#'    flowSOM.res <- BuildMST(flowSOM.res)
#'    
#'    # Plot centers
#'    PlotCenters(flowSOM.res,"FSC-A","SSC-A")
#'    PlotCenters(flowSOM.res,2,5)
#'
#' @export
PlotCenters <- function(fsom, marker1, marker2, MST=TRUE){
    
    plot(fsom$data[, c(marker1, marker2)], pch=".", col="#000000AA")
    d <- fsom$map$medianValues[, c(marker1, marker2)]
    points(d,col="red")
    
    if(MST==1){
        g <- fsom$MST$graph
        e <- get.edges(g, E(g))
    } else {
        e <- which(as.matrix(
            stats::dist(fsom$map$grid,method = "manhattan"))==1,
            arr.ind=TRUE)
    }
    
    for(i in seq_len(nrow(e))){
        lines(d[c(e[i, 1], e[i, 2]), 1], d[c(e[i, 1], e[i, 2]), 2], col="red")
    }
}

#' FlowSOM subset
#' 
#' Take a subset from a FlowSOM object
#' 
#' @param fsom FlowSOM object, as generated by \code{\link{BuildMST}}
#' @param ids  Array containing the ids to keep
#' 
#' @return FlowSOM object containg updated data and medianvalues, 
#'    but with the same grid
#' @seealso \code{\link{BuildMST}}
#' 
#' @examples
#'    # Read two files (Artificially, as we just split 1 file in 2 subsets)
#'    fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#'    ff1 <- read.FCS(fileName)[1:1000,]
#'    ff1@@description$FIL <- "File1"
#'    ff2 <- read.FCS(fileName)[1001:2000,]
#'    ff2@@description$FIL <- "File2"
#'    
#'    flowSOM.res <- FlowSOM(flowSet(c(ff1,ff2)), compensate=TRUE,
#'                           transform=TRUE, scale=TRUE,
#'                           colsToUse=c(9,12,14:18), maxMeta=10)
#'    fSOM <- flowSOM.res[[1]]
#'    
#'    # see $metadata for subsets:
#'    fSOM$metaData
#'    
#'    # Use only the second file, without changing the map
#'    fSOM2 <- FlowSOMSubset(fSOM,
#'                           (fSOM$metaData[[2]][1]):(fSOM$metaData[[2]][2]))
#'
#' @export
FlowSOMSubset <- function(fsom,ids){
    fsom_tmp <- fsom
    fsom_tmp$data <- fsom$data[ids,]
    fsom_tmp$map$mapping <- fsom$map$mapping[ids,]
    aggr <- aggregate(fsom_tmp$data,by=list(fsom_tmp$map$mapping[,1]),mean)
    fsom_tmp$map$medianValues <- matrix(0,nrow = nrow(fsom$map$grid),
                                    ncol = ncol(fsom$map$medianValues))
    fsom_tmp$map$medianValues[aggr[,1],] <- as.matrix(aggr[,-1])
    UpdateNodeSize(fsom_tmp)
}

#' Map new data to a FlowSOM grid
#'
#' New data from a flowframe is mapped to an existing FlowSOM 
#' object. A new FlowSOM object is created, with the same grid, but a new
#' mapping, node sizes and mean values. We assume the data is already
#' compensated and transformed, but not scaled yet. The same scaling parameters
#' as from the original grid will be used.
#'
#' @param fsom FlowSOM object
#' @param ff   Flow frame with the data to map
#'        
#' @return A new FlowSOM object
#' @seealso \code{\link{FlowSOMSubset}} if you want to get a subset of the
#'          current data instead of a new dataset
#' @examples 
#'  # Build FlowSom result
#'  fileName <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#'    ff <- read.FCS(fileName)
#'    ff <- compensate(ff,ff@@description$SPILL)
#'    ff <- transform(ff,transformList(colnames(ff@@description$SPILL),
#'                                     logicleTransform()))
#'    flowSOM.res <- FlowSOM(ff[1:1000,],scale=TRUE,colsToUse=c(9,12,14:18),
#'                           maxMeta=10)
#'    
#'    # Map new data
#'    fSOM2 <- NewData(flowSOM.res[[1]], ff[1001:2000,])
#'
#' @export
NewData <- function(fsom,ff){
    fsom_tmp <- fsom
    
    if(fsom$compensate){
        ff <- flowCore::compensate(ff,fsom$spillover)    
    }
    if(fsom$transform){
        ff <- flowCore::transform(ff,flowCore::transformList(
            BiocGenerics::colnames(ff[,fsom$toTransform]),
            fsom$transformFunction))
    }
    
    if(fsom$scale){
        newData <- scale(exprs(ff),
                        center = fsom$scaled.center[
                            BiocGenerics::colnames(ff)],
                        scale = fsom$scaled.scale[
                            BiocGenerics::colnames(ff)])
    } else {
        newData <- exprs(ff)
    }
    
    fsom_tmp$data <- newData
    fsom_tmp$map$mapping <- MapDataToCodes(fsom$map$codes,newData)
    aggr <- aggregate(fsom_tmp$data,by=list(fsom_tmp$map$mapping[,1]),mean)
    fsom_tmp$map$medianValues <- matrix(NA,nrow = nrow(fsom$map$grid),
                                    ncol = ncol(fsom$map$medianValues),
                                    dimnames=list(NULL,
                                            colnames(fsom$map$medianValues)))
    fsom_tmp$map$medianValues[aggr[,1],colnames(aggr[,-1])] <- 
        as.matrix(aggr[,-1])
    UpdateNodeSize(fsom_tmp)
}

#' Plot differences between groups
#' 
#' Plot FlowSOM trees, where each node is represented by 
#' a star chart indicating mean marker values, the size of the node is relative
#' to the mean percentage of cells present in each
#'
#' @param fsom    FlowSOM object, as generated by \code{\link{BuildMST}} or
#'        the first list item of \code{\link{FlowSOM}}
#' @param groups  groups result as generated by \code{\link{CountGroups}}
#' @param view     Preferred view, options: "MST", "grid" or "tSNE" (if this
#'                 option was selected while building the MST)
#' @param tresh   Relative difference in groups before the node is coloured
#' @param p_tresh Threshold on p-value from t-test before the node is
#'        coloured. If this is not NULL, tresh will be ignored.
#' @param heatmap   If TRUE, the scores are plotted in a gradient instead
#'                  of only the selection that passes the threshold
#' @param ... Other parameters to pass to \code{\link{PlotStars}}
#' @return A vector containing the labels assigned to the nodes for
#'         all groups except the first
#' @seealso \code{\link{PlotStars}},\code{\link{CountGroups}}
#' @examples
#'    ## Use the wrapper function to build a flowSOM object (saved in fsom[[1]])
#'    ## and a metaclustering (saved in fsom[[2]])
#'    # fsom <- FlowSOM(ff,compensate = FALSE, transform = FALSE,scale = TRUE,
#'    #               colsToUse = colsToUse, nClus = 10, silent = FALSE,
#'    #               xdim=7, ydim=7)
#'    
#'    ## Make a list with for each group a list of files
#'    ## The reference group should be the first
#'    #groups <- list("C"=file.path(workDir,grep("C",files,value = TRUE)),
#'   #          "D"=file.path(workDir,grep("D",files,value=TRUE)))
#'    
#'    ## Compute the percentages for all groups
#'    # groups_res <- CountGroups(fsom[[1]],groups)
#'   
#'    ## Plot the groups. For all groups except the first, differences with the
#'    ## first group are indicated
#'    # annotation <- PlotGroups(fsom[[1]],groups_res)
#'    
#'    @export
PlotGroups <- function(fsom,groups,view="MST",tresh = 0.5, p_tresh=NULL, 
                        heatmap=FALSE,...){
    groupnames <- rownames(groups$means)
    
    
    fsom <- UpdateNodeSize(fsom,reset=TRUE)
    fsom$MST$size <- fsom$MST$size * groups$means_norm[[groupnames[1]]]
    PlotStars(fsom,main=groupnames[1],view=view,...)
    
    annotation <- list()
    if(!heatmap){
        if(! is.null(p_tresh)){
            values <- groups$pctgs
            for(group in groupnames[-1]){
                score <- rep(NA,ncol(values))
                for(i in seq_len(ncol(values))){
                    test <- wilcox.test(values[groups$groups %in% 
                                            groupnames[1],i],
                                        values[groups$groups %in% group,i])
                    #boxplot(counts[1:5,i],counts[11:15,i],main=test$p.value)
                    adj_p <- p.adjust(test$p.value,"BH")
                    diff <- groups$means[group,i] - 
                        groups$means[groupnames[1],i]
                    score[i] <- 1 + (adj_p < p_tresh) + 
                        (diff > 0 & adj_p < p_tresh)
                }
                annotation[[group]] <- factor(c("--",
                                                groupnames[1],
                                                group)[score],
                                            levels=c("--",groupnames[1],group))
            }
            
        } else {
            for(group in groupnames[-1]){
                diff <- groups$means[group,] - groups$means[1,]
                values <- abs(diff) / 
                    apply(groups$means[c(groupnames[1],group),],2,max)
                annotation[[group]] <- as.factor(c("--",groupnames[1],group)[
                    1 + (values > tresh) + (diff > 0 & values > tresh)])
            }
        }
        
        for(group in groupnames[-1]){
            fsom <- UpdateNodeSize(fsom,reset=TRUE)
            fsom$MST$size <- fsom$MST$size * groups$means_norm[[group]]
            PlotStars(fsom,backgroundValues = annotation[[group]],main=group,
                      view=view,
                      backgroundColor = colorRampPalette(
                        c("#FFFFFF","#00FFFF55","#FF000055"),alpha=TRUE),...)
        }
    } else {
        if(! is.null(p_tresh)){
            values <- groups$pctgs
            for(group in groupnames[-1]){
                score <- rep(NA,ncol(values))
                for(i in seq_len(ncol(values))){
                    test <- wilcox.test(values[groups$groups %in% 
                                            groupnames[1],i],
                                        values[groups$groups %in% group,i])
                    #boxplot(counts[1:5,i],counts[11:15,i],main=test$p.value)
                    adj_p <- p.adjust(test$p.value,"BH")
                    diff <- groups$means[group,i] - 
                        groups$means[groupnames[1],i]
                    score[i] <- adj_p * (-1)^(diff < 0)
                }
                annotation[[group]] <- score
            }
            
        } else {
            for(group in groupnames[-1]){
                #diff <- groups$means[group,] - groups$means[1,]
                #values <- abs(diff) / 
                #    apply(groups$means[c(groupnames[1],group),],2,max)
                values <- (apply(groups$means[c(groupnames[1],group),],2,max) / 
                        apply(groups$means[c(groupnames[1],group),],2,min)) -1
                annotation[[group]] <- values * (-1)^(diff < 0)
            }
        }
        
        for(group in groupnames[-1]){
            fsom <- UpdateNodeSize(fsom,reset=TRUE)
            fsom$MST$size <- fsom$MST$size * groups$means_norm[[group]]
            clusterCols <- colorRampPalette(c("#FFFFFF","#FF000077"),
                                            alpha=TRUE)(49)[
                                                order(annotation[[group]])]
            PlotStars(fsom,backgroundValues =annotation[[group]],main=group,
                    view=view,backgroundColor =clusterCols,...)
        }
    }
    annotation
}




#' Query a certain cell type
#' 
#' Identify nodes in the tree which resemble a certain profile of "high"
#' or "low" marker expressions.
#'
#' @param fsom    FlowSOM object, as generated by \code{\link{BuildMST}} or
#'        the first list item of \code{\link{FlowSOM}}
#' @param query  Array containing "high" or "low" for the specified column
#'               names of the FlowSOM data
#' @param plot   If true, a plot with a gradient of scores for the nodes is 
#'               shown
#' @param color  Color to use for nodes with a high score in the plot
#' @param debug  If TRUE, some extra output will be printed
#' @param ...    Other parameters to pass to \code{\link{PlotStars}}
#' @return A list, containing the ids of the selected nodes, the individual
#'         scores for all nodes and the scores for each marker for each node
#' @examples
#'    file <- system.file("extdata","lymphocytes.fcs",package="FlowSOM")
#'    # Use the wrapper function to build a flowSOM object (saved in fsom[[1]])
#'    # and a metaclustering (saved in fsom[[2]])
#'    fsom <- FlowSOM(file,compensate = TRUE, transform = TRUE,scale = TRUE,
#'                   colsToUse = c(9,12,14:18), nClus = 10, silent = FALSE,
#'                   xdim=7, ydim=7)
#'    query <- c("PE-Cy7-A" = "high", #CD3
#'               "APC-Cy7-A" = "high", #TCRb
#'               "Pacific Blue-A" = "high") #CD8
#'    query_res <- QueryStarPlot(UpdateNodeSize(fsom[[1]],reset=TRUE), query)
#'    
#'    cellTypes <- factor(rep("Unknown",49),levels=c("Unknown","CD8 T cells"))
#'    cellTypes[query_res$selected] <- "CD8 T cells"
#'    PlotStars(fsom[[1]],
#'                  backgroundValues=cellTypes,
#'                  backgroundColor=c("#FFFFFF00","#ca0020aa"))
#'    
#' @export
QueryStarPlot <- function(fsom, query, plot=TRUE,
                            color="#ca0020",debug=FALSE,...){
    
    scores <- matrix(NA,
                    ncol=length(query),
                    nrow=nrow(fsom$map$medianValues),
                    dimnames=list(NULL,names(query)))
    
    for(marker in names(query)){
        data <- fsom$map$medianValues[,marker]
        if(query[marker]=="high"){
            scores[,marker] = (max(data,na.rm = TRUE) - data)^2
        } else if(query[marker]=="low"){
            scores[,marker] = (data - min(data,na.rm = TRUE))^2
        } else {
            stop("Only high or low marker expressions are 
                 supported at the moment")
        }
    }
    
    if(debug){
        message("Scores")
        print(scores)
    }
    
    # Normalize between 0 and 1 and make highest score best
    scores <- apply(scores,2,function(x){1-((x-min(x,na.rm=TRUE))/
                                    (max(x,na.rm=TRUE)-min(x,na.rm=TRUE)))})
    if(debug){
        message("Normalized")
        print(scores)
    }
    
    nodeScores <- apply(scores,1,mean)
    nodeScores[is.na(nodeScores)] <- 0
    if(debug){
        message("nodeScores")
        print(nodeScores)
    }
    
    if(plot){
        PlotStars(fsom, 
                markers = names(query),
                backgroundValues = nodeScores,
                backgroundColor = colorRampPalette(c("#ffffff","#ffffff",
                                                        "#ffffff",color)),
                query = query,
                ...)
    }

    cutoff <- max(nodeScores) *0.95

    scores_cutoff <- nodeScores > cutoff

    return(list("selected"=which(scores_cutoff),
                "nodeScores"=nodeScores,
                "fullScores"=scores))
}
